{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/ch01-clean-code","result":{"data":{"markdownRemark":{"id":"27491274-a7a1-56bc-90fc-27fdab905cf4","html":"<h3 id=\"코드가-존재하리라\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C%EA%B0%80-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%A6%AC%EB%9D%BC\" aria-label=\"코드가 존재하리라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>코드가 존재하리라</strong></h3>\n<p>: 코드는 요구사항을 표현하는 언어 (잘짜여진 요구사항은 테스트 케이스로 써도 좋다)</p>\n<ul>\n<li>스스로 요구사항을 결정하는 기계가 나타나지 않는다면, 코드는 존재하리라</li>\n</ul>\n<h3 id=\"나쁜-코드\" style=\"position:relative;\"><a href=\"#%EB%82%98%EC%81%9C-%EC%BD%94%EB%93%9C\" aria-label=\"나쁜 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>나쁜 코드</strong></h3>\n<p>: 고행(wading) = 나쁜코드를 헤쳐나감</p>\n<p>: 르블랑의 법칙(leblanc’s Law) = <strong>나중은 결코오지 않는다.</strong></p>\n<ul>\n<li>밀린 업무로 급하게 작성된 나쁜코드는 이후에도 고쳐지지 않는다.</li>\n</ul>\n<h3 id=\"나쁜-코드로-치르는-대가\" style=\"position:relative;\"><a href=\"#%EB%82%98%EC%81%9C-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%B9%98%EB%A5%B4%EB%8A%94-%EB%8C%80%EA%B0%80\" aria-label=\"나쁜 코드로 치르는 대가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>나쁜 코드로 치르는 대가</strong></h3>\n<p>: 해독 + 생산성 저하</p>\n<p><em>원대한 재설계의 꿈</em></p>\n<p>막대한 투자비용&#x26;시간</p>\n<ul>\n<li>깨끗한 코드를 만드는 것이 <strong>비용을 절감</strong> + <strong>전문가</strong>로 살아남는 길</li>\n</ul>\n<p><em>태도</em></p>\n<p>나쁜코드는 모두 우리의 탓이다. (고객이나 일정, 변경되는 설계의 문제가 아니다.)</p>\n<p><strong>우리는 전문가 답지 못했다.</strong></p>\n<p>우리가 의사 였다면? 바쁘다고 손도 안씻고 환자를 볼순 없지 않은가?</p>\n<ul>\n<li>좋은 코드를 사수하는건 <strong>프로그래머의 책임</strong>이다.</li>\n</ul>\n<p><em>원초적 난제</em></p>\n<p>기한을 맞추기 위한 나쁜 코드 양산</p>\n<p><strong>BUT</strong> 결과적으로는, 나쁜코드 = 생산속도 저하 = 기한을 맞추기 못하게됨</p>\n<ul>\n<li>그러니까 깨끗한 코드가 답이다.</li>\n</ul>\n<h3 id=\"깨끗한-코드라는-예술\" style=\"position:relative;\"><a href=\"#%EA%B9%A8%EB%81%97%ED%95%9C-%EC%BD%94%EB%93%9C%EB%9D%BC%EB%8A%94-%EC%98%88%EC%88%A0\" aria-label=\"깨끗한 코드라는 예술 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>깨끗한 코드라는 예술?</strong></h3>\n<p>: 나쁜코드는 장애물</p>\n<p>: 빠르게 가기 위해서는 깨끗한 코드가 답</p>\n<p>: 잘그린 그림을 구별 하는 능력 &#x3C;> 그림을 잘그리는 능력</p>\n<ul>\n<li>코드감각 = 단순히 나쁜 코드를 구별 하는것만 이 아닌, 좋은코드로 변화 시킬 방안을 생각</li>\n</ul>\n<h3 id=\"깨끗한-코드란\" style=\"position:relative;\"><a href=\"#%EA%B9%A8%EB%81%97%ED%95%9C-%EC%BD%94%EB%93%9C%EB%9E%80\" aria-label=\"깨끗한 코드란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>깨끗한 코드란?</strong></h3>\n<p>비야네 스트롭스트룹(Bjarne Stroustrup)</p>\n<p><strong>우아한</strong> = 보기에 즐거운 코드</p>\n<p><strong>효율</strong> = 속도 + CPU</p>\n<p>나쁜코는 나쁜 코드를 <strong>유혹</strong> 한다. ( 일단 창문이 깨지고 나면, 쇠퇴하는 과정이 시작된다.)</p>\n<p>오류처리 = 세세한 사항 까지 꼼꼼히 ( 메모리누수, <a href=\"https://ko.wikipedia.org/wiki/%EA%B2%BD%EC%9F%81_%EC%83%81%ED%83%9C\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">경쟁상태</a>, 일관성 없는 명명법 )</p>\n<p>한 가지에 <strong>집중</strong>한다.</p>\n<p>그래디 부치(Grady Booch)</p>\n<p><strong>가독성</strong>이 좋은 코드 ( 깨끗한 코드는 잘 쓴 문장처럼 읽혀야 한다. )</p>\n<p>의도를 숨기지 않는다.</p>\n<p><strong>명쾌한 추상화</strong>와 단순한 제어문</p>\n<p>‘큰big’데이브 토마스(Dave Thomas)</p>\n<p><strong>가독성</strong>이 좋은 코드 ( 작성자가 아니어도 읽고 <strong>고치기</strong> 쉬움 )</p>\n<p>단위 테스트 + 인수 테스트 존재</p>\n<p>하나의 목적을 달성하는 방법은 하나</p>\n<p>의존성을 최소 + API는 명확하며 최소</p>\n<p>마이클 페더스(Michael Feathers)</p>\n<p><strong>주의</strong> 깊게 짜여진 코드</p>\n<p>론 제프리스(Ron Jeffries) *</p>\n<p>모든 테스트를 통과한다.</p>\n<p>중복이 없다.</p>\n<p>시스템 내 모든 설계 아이디어를 표현한다.</p>\n<p>클래스, 메서드, 함수 들을 최대한 줄인다.</p>\n<ul>\n<li>중복 줄이기 + 표현력 높이기 + 초반부터 간단한 추상화 고려</li>\n</ul>\n<p>워드 커닝햄(Ward Cunnningham)</p>\n<p>짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드 ( 깨끗한 코드는 독해 할필요가 없다. )</p>\n<p>코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드</p>\n<h3 id=\"우리는-저자다\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EB%A6%AC%EB%8A%94-%EC%A0%80%EC%9E%90%EB%8B%A4\" aria-label=\"우리는 저자다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>우리는 저자다</strong></h3>\n<p>: Javadoc에서 @author = 저자</p>\n<p>: 독자와 소통할 <strong>책임</strong>이 있다.</p>\n<p>: 새로운 코드를 작성하기 위해 기존코드를 수없이 읽는다. 그러므로, 읽기 쉬운 코드를 짜야한다.</p>\n<h3 id=\"보이스카우트-규칙\" style=\"position:relative;\"><a href=\"#%EB%B3%B4%EC%9D%B4%EC%8A%A4%EC%B9%B4%EC%9A%B0%ED%8A%B8-%EA%B7%9C%EC%B9%99\" aria-label=\"보이스카우트 규칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>보이스카우트 규칙</strong></h3>\n<p>캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.</p>\n<ul>\n<li>시간이 지날수록 코드가 좋아지는 프로젝트를 만들자.</li>\n</ul>\n<p><strong>객체지향 프로그래밍의 5원칙 (SOLID)</strong></p>\n<ul>\n<li>\n<p><strong>SRP: 단일 책임 원칙(single responsibility principle)</strong></p>\n<p>하나의 클래스는 하나의 책임.</p>\n<p>중요한 기준은 변경이다. <em>변경이 있을때, 파급효과가 적으면 잘한것.</em></p>\n</li>\n<li>\n<p><strong>OCP: 개방-폐쇄 원칙 (Open/closed principle)</strong></p>\n<p><strong>확장에는 열려</strong> 있으나, <strong>변경에는 닫혀</strong> 있어야 한다.</p>\n<p>다형성 - 인터페이스를 구현한 새로운 클래스를 만들어 새로운 기능을 구현</p>\n<p>Object obj = new obj1();</p>\n<p>Object obj = new obj2();</p>\n<p>구현객체를 변경하려면, 클라이언트 코드를 변경해야 한다.</p>\n</li>\n<li>\n<p>LSP: 리스코프 치환 원칙 (Liskov substitution principle)</p>\n<p>하위 클래스는 인터페이스의 규약을 지켜야한다. 단순히 컴파일 에러 수준 아님.</p>\n<p>ex. 자동차의 엑셀은 앞으로 가야한다. 뒤로가면 안됨.</p>\n</li>\n<li>\n<p>ISP: 인터페이스 분리 원칙 (Interface segregation principle)</p>\n<p>특정 클라인언트를 위한 인터페이스가 여러 범용 인터페이스 하나보다 낫다.</p>\n</li>\n<li>\n<p><strong>DIP: 의존관계 역전 원칙 (Dependency inversion principle)</strong></p>\n<p>추상화에 의존해야지, 구체화에 의존하면 안된다. = 역할에 의존해야함.</p>\n</li>\n</ul>","fields":{"slug":"/posts/ch01-clean-code","tagSlugs":["/tag/clean-code/"]},"frontmatter":{"date":"2021-06-13T14:47:00","description":"클린코드 리뷰","tags":["Clean Code"],"title":"1장 깨끗한 코드","socialImage":null}}},"pageContext":{"slug":"/posts/ch01-clean-code"}},"staticQueryHashes":["251939775","401334301","825871152"]}